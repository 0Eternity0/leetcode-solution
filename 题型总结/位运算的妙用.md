## 位运算的妙用

### 异或的妙用
例如： 1^1=0  1^2!=0  1^0=1 1^2^1=1^1^2=2
根据上面的例子不难看出，偶数个相同的数字异或后为0.所以我们可以利用这个性值。
#### 典型的例题：
136.只出现一次的数字
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
```java
class Solution {
    public int singleNumber(int[] nums) {
        int result=0;
        for(int num:nums){
            result^=num;
        }
        return result;
    }
}
```

268 缺失数字
给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

分析：
需要我们从n个数字的序列中，找出0-n中没有出现过的数字。换个思路，也就是说0-n个数字中，只有一个数字没有出现，其它数字都出现了一次。根据之前异或的性值。我们可以将序列中的数字和（0-n）的数字进行异或。序列中出现过的数字，也就有了两个，这样异或后就抵消了。剩下的就是只出现一次的，也就是序列中没有出现过的数字。
```java
//当然这道题用位运算其实不是最好的解法
class Solution {
    public int missingNumber(int[] nums) {
         int missing = nums.length;
        for (int i = 0; i < nums.length; i++) {
            missing ^= i ^ nums[i];
        }
        return missing;

        
    }
}
```



### 使用位运算来判断一个数是否是2的幂次方
是2的幂次方的数有什么的二进制表示有什么特点？
0次方  0000 0000
1次方  0000 0010
2次方  0000 0100
3次方  0000 1000

根据上面的举例不难看出，2的幂次方的数首先不能是负数，第二，它的二进制表示中，只能有一个1。
#### 典型的例题：
231 2的幂
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。


分析：
通过上面的规律我们需要判断数字的二进制表示中有多少个1，这个我们需要借助位运行的与运算来实现。
```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n<0){
            return false;
        }
        int oneCount=0;
        for(int i=0;i<32;i++){
            //通过与运算来判断地址最高位是否为1
            if((n&0x1)==1){
                oneCount++;
            }
            //右移
            n>>=1;
        }
        return oneCount==1?true:false;
    }
}
```

###  使用位运算来代替加减运算符

典型例题：
371 两整数之和
不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。

分析：
要使用位运算来代替加减运算，就需要分析一波。位运算是如何实现加法的。
0 + 0 =0
0 + 1 =1
1 + 0 =1
1 + 1 =0（进位1）
很明显的规律就是相同位为0，不同位为1.也就是异或。

那么它的进位有什么特点呢？
比如：5+4
```
    0101
   +0100
   ——————
    0100
```
很明显，进位就是按位与。
但是进位是应该放在高一位的，所以我们需要将进位结果左移一位。

所以我们的解放方案是：
1. a+b的计算方案拆分为(a+b的无进位结果)+(a+b的进位结果)
2. 循环这个操作，直到进位为0为止（可以递归）

```java
class Solution {
    public int getSum(int a, int b) {
        if(b==0){
            //直到进位为0，就直接返回无进位结果
            return a; //语句一
        }
        //计算进位
        int out=(a&b)<<1;
        //计算无进位结果
        int n=a^b;
        //递归调用，直到达到递归基线，也就是语句一
        return getSum(n, out);
        
    }
}
```

### 使用位运算来实现数字转16进制

典型例题：
405 数字转换为十六进制数
给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

分析：
如果我们直接按照概念去计算16进制，那么处理负数将会变得非常困难。但是我们可以借助位运算，因为数字在计算机内部就是补码保存。我们可以利用这点，绕过处理负数的困难。并且我们知道一个16进制位由4个二进制位表示。我们可以以4个二进制位一组计算出16进制位就可以了。
```java
import java.util.Stack;
class Solution {
    public String toHex(int num) {
        char[] Hex={'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};
        String result="";
        if(num==0){
            return "0";
        }
        
        Stack stack=new Stack<Character>();
       for(int i=0;num!=0&&i<8;i++){
           stack.push(Hex[num&0xf]);
           num=num>>4;
       }

       while(stack.size()!=0){
           result+=stack.pop();
       }

       return result;
        
    
    }
}
```